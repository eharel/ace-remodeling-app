/**
 * Firebase Database Seeding Script
 *
 * This script seeds the Firestore database with project data from
 * uploaded Firebase Storage JSON files (generated by uploadPhotos.ts).
 *
 * Usage:
 *   npm run seed
 *
 * WARNING: This will DELETE all existing projects in the database.
 * Only use in development environments.
 *
 * @module scripts/seedFirebase
 */

import {
  addDoc,
  collection,
  deleteDoc,
  DocumentData,
  getDocs,
  QueryDocumentSnapshot,
} from "firebase/firestore";
import * as fs from "fs";
import * as path from "path";
import { db } from "../core/config";
import { Document, Picture, Project, ProjectCategory } from "../core/types";

/**
 * Result summary from seeding operation
 */
interface SeedResult {
  success: boolean;
  projectsDeleted: number;
  projectsAdded: number;
  errors: string[];
  duration: number;
}

/**
 * Uploaded project data structure from Firebase Storage
 */
interface UploadedProject {
  id: string;
  slug: string;
  name: string;
  category: string;
  subcategory?: string; // Only present for adu-addition category
  photos: {
    url: string;
    category: string;
    filename: string;
    storagePath: string;
    size: number;
    order: number;
  }[];
  documents: {
    url: string;
    category: string;
    filename: string;
    storagePath: string;
    size: number;
    type: string;
  }[];
}

/**
 * Load uploaded projects from JSON files
 * Looks for all *-projects.json files in environment-specific output folder
 * - Development: scripts/output/dev/
 * - Production: scripts/output/prod/
 */
function loadUploadedProjects(): UploadedProject[] {
  const uploadedProjects: UploadedProject[] = [];

  try {
    // Determine environment-specific folder
    const isProduction = process.env.NODE_ENV === "production";
    const envFolder = isProduction ? "prod" : "dev";
    const outputDir = path.join(__dirname, "output", envFolder);

    console.log(`üìÇ Loading from: output/${envFolder}/`);

    if (!fs.existsSync(outputDir)) {
      console.log(`‚ÑπÔ∏è  No ${envFolder} output directory found, no projects to seed`);
      return [];
    }

    // Find all JSON files in output directory
    const files = fs
      .readdirSync(outputDir)
      .filter((f) => f.endsWith("-projects.json"));

    if (files.length === 0) {
      console.log(`‚ÑπÔ∏è  No uploaded project files found in ${envFolder} output directory`);
      return [];
    }

    // Load each JSON file
    for (const file of files) {
      const filePath = path.join(outputDir, file);
      const jsonData = fs.readFileSync(filePath, "utf-8");
      const data = JSON.parse(jsonData);

      if (data.projects && Array.isArray(data.projects)) {
        uploadedProjects.push(...data.projects);
        console.log(`‚úÖ Loaded ${data.projects.length} projects from ${file}`);
      }
    }

    console.log(
      `‚úÖ Total: ${uploadedProjects.length} uploaded projects from Firebase Storage`
    );
    return uploadedProjects;
  } catch (error) {
    console.warn("‚ö†Ô∏è  Error loading uploaded projects:", error);
    return [];
  }
}

/**
 * Convert uploaded project data to Firestore format
 *
 * @param uploadedProject - Project data from Firebase Storage upload
 * @returns Project object ready for Firestore
 */
function convertUploadedProject(
  uploadedProject: UploadedProject
): Omit<Project, "id"> {
  // Map photos from uploaded format to Picture format
  const pictures: Picture[] = uploadedProject.photos.map((photo) => ({
    id: `${uploadedProject.slug}-photo-${photo.order}`,
    url: photo.url,
    type: mapCategoryToType(photo.category),
    category: photo.category,
    order: photo.order,
    filename: photo.filename,
    storagePath: photo.storagePath,
    size: photo.size,
    altText: `${uploadedProject.name} - ${photo.category} photo`,
    createdAt: new Date().toISOString(),
  }));

  // Map documents from uploaded format to Document format
  const documents: Document[] = (uploadedProject.documents || []).map(
    (doc) => ({
      id: `${uploadedProject.slug}-doc-${doc.filename}`,
      name: doc.filename,
      url: doc.url,
      type: mapDocumentType(doc.type), // Map to valid DocumentType
      category: doc.category,
      fileType: "PDF",
      fileSize: doc.size,
      description: `${doc.type} for ${uploadedProject.name}`,
      uploadedAt: new Date().toISOString(),
      storagePath: doc.storagePath,
    })
  );

  return {
    projectNumber: uploadedProject.id,
    name: uploadedProject.name,
    category: uploadedProject.category as ProjectCategory,
    // Only include subcategory if it exists (for adu-addition projects)
    ...(uploadedProject.subcategory && {
      subcategory: uploadedProject.subcategory as any,
    }),
    briefDescription: `Professional ${uploadedProject.category} remodeling project`,
    longDescription: `This ${uploadedProject.category} remodeling project showcases our expertise in transforming spaces with quality craftsmanship and attention to detail.`,
    thumbnail:
      pictures.find((p) => p.type === "after")?.url || pictures[0]?.url || "",
    location: {
      zipCode: "78701",
      neighborhood: "Austin, TX",
    },
    projectDates: {
      start: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString(), // 90 days ago
      end: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(), // 30 days ago
    },
    scope: `Complete ${uploadedProject.category} transformation including design, demolition, and installation.`,
    pms: [{ name: "Mike Johnson" }],
    pictures,
    documents,
    logs: [],
    status: "completed" as const,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    tags: [uploadedProject.category, "remodel", "completed"],
  };
}

/**
 * Map upload category to Picture type
 */
function mapCategoryToType(category: string): Picture["type"] {
  const mapping: Record<string, Picture["type"]> = {
    before: "before",
    after: "after",
    progress: "progress",
    rendering: "rendering",
    materials: "detail",
    other: "other",
  };
  return mapping[category] || "other";
}

/**
 * Map upload document type string to DocumentType
 */
function mapDocumentType(typeString: string): Document["type"] {
  // Direct matches from DOCUMENT_TYPE_NAMES in uploadConfig
  const mapping: Record<string, Document["type"]> = {
    "3D Rendering": "3D Rendering",
    "Floor Plan": "Floor Plan",
    Permit: "Permit",
    Contract: "Contract",
    Invoice: "Invoice",
    Document: "Other",
    Other: "Other",
  };
  return mapping[typeString] || "Other";
}

/**
 * Validates that a project object has all required fields
 *
 * @param project - The project object to validate
 * @returns True if valid, throws error if invalid
 * @throws Error with descriptive message if validation fails
 */
function validateProject(project: Omit<Project, "id">): boolean {
  const requiredFields = [
    "projectNumber",
    "name",
    "category",
    "briefDescription",
    "longDescription",
    "thumbnail",
    "pictures",
    "documents",
    "logs",
    "status",
    "createdAt",
    "updatedAt",
  ];

  for (const field of requiredFields) {
    if (!(field in project)) {
      throw new Error(
        `Project "${
          project.name || "Unknown"
        }" is missing required field: ${field}`
      );
    }
  }

  // Validate field types
  if (
    typeof project.projectNumber !== "string" ||
    project.projectNumber.trim() === ""
  ) {
    throw new Error("Project number must be a non-empty string");
  }

  if (typeof project.name !== "string" || project.name.trim() === "") {
    throw new Error("Project name must be a non-empty string");
  }

  if (!Array.isArray(project.pictures)) {
    throw new Error("Project pictures must be an array");
  }

  if (!Array.isArray(project.documents)) {
    throw new Error("Project documents must be an array");
  }

  if (!Array.isArray(project.logs)) {
    throw new Error("Project logs must be an array");
  }

  // Validate dates are ISO strings
  const dateFields = ["createdAt", "updatedAt"];
  for (const field of dateFields) {
    const value = project[field as keyof typeof project];
    if (typeof value === "string") {
      const date = new Date(value);
      if (isNaN(date.getTime())) {
        throw new Error(`Project ${field} must be a valid ISO date string`);
      }
    }
  }

  return true;
}

/**
 * Clears all existing projects from the Firestore database
 *
 * @returns Promise resolving to number of projects deleted
 * @throws Error if deletion fails
 */
async function clearProjects(): Promise<number> {
  console.log("üóëÔ∏è  Clearing existing projects...");

  try {
    const projectsCollection = collection(db, "projects");
    const snapshot = await getDocs(projectsCollection);

    if (snapshot.empty) {
      console.log("   No existing projects to delete");
      return 0;
    }

    const deletePromises: Promise<void>[] = [];

    snapshot.forEach((doc: QueryDocumentSnapshot<DocumentData>) => {
      deletePromises.push(deleteDoc(doc.ref));
    });

    await Promise.all(deletePromises);

    const count = snapshot.size;
    console.log(`‚úÖ Deleted ${count} existing project(s)`);

    return count;
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : "Unknown error";
    console.error("‚ùå Error clearing projects:", errorMessage);
    throw new Error(`Failed to clear projects: ${errorMessage}`);
  }
}

/**
 * Adds seed projects to the Firestore database
 *
 * @returns Promise resolving to object with success count and errors
 * @throws Error if seeding fails completely
 */
async function addSeedProjects(): Promise<{
  successCount: number;
  errors: string[];
}> {
  // Load uploaded projects
  const uploadedProjects = loadUploadedProjects();

  if (uploadedProjects.length === 0) {
    console.log("\n‚ö†Ô∏è  No uploaded projects found.");
    console.log(
      "   Run 'npm run upload -- --category <category>' first to upload projects.\n"
    );
    return { successCount: 0, errors: [] };
  }

  // Convert uploaded projects to seed format
  const projectsToSeed = uploadedProjects.map(convertUploadedProject);
  console.log(
    `\nüì¶ Adding ${projectsToSeed.length} projects from Firebase Storage...`
  );
  console.log(
    `   (${uploadedProjects.length} uploaded projects with real photos)\n`
  );

  const errors: string[] = [];
  let successCount = 0;

  for (const project of projectsToSeed) {
    try {
      // Validate project data before inserting
      validateProject(project);

      // Add to Firestore
      const projectsCollection = collection(db, "projects");
      const docRef = await addDoc(projectsCollection, project);

      successCount++;

      // Build details string
      const photoCount = `${project.pictures.length} photo${
        project.pictures.length !== 1 ? "s" : ""
      }`;
      const docCount = project.documents?.length || 0;
      const docString =
        docCount > 0 ? `, ${docCount} doc${docCount !== 1 ? "s" : ""}` : "";

      // Show subcategory if present
      const subcategoryString = project.subcategory
        ? ` [${project.subcategory}]`
        : "";

      console.log(
        `   üé® Added: "${project.name}" (${project.category}${subcategoryString}, ${photoCount}${docString}) - ID: ${docRef.id}`
      );
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";
      const errorDetail = `Failed to add "${project.name}": ${errorMessage}`;

      errors.push(errorDetail);
      console.error(`   ‚úó ${errorDetail}`);
    }
  }

  return { successCount, errors };
}

/**
 * Main function that orchestrates the database seeding process
 *
 * Performs the following steps:
 * 1. Clears all existing projects
 * 2. Validates seed data
 * 3. Adds new seed projects
 * 4. Reports results
 *
 * @returns Promise resolving to SeedResult object
 */
async function main(): Promise<SeedResult> {
  const startTime = Date.now();

  // Log which Firebase we're targeting
  console.log("\nüå± Starting Firebase Database Seeding");
  console.log("=====================================");

  // Detect environment (same logic as firebase.ts)
  const isProduction = process.env.NODE_ENV === "production";
  const environment = isProduction ? "production" : "development";

  console.log(`üîß Environment: ${environment}`);
  console.log(
    `üóÑÔ∏è  Target Database: ${
      isProduction ? "ace-remodeling" : "ace-remodeling-dev"
    }`
  );

  if (isProduction) {
    console.log("\n‚ö†Ô∏è  WARNING: You are about to modify PRODUCTION database!");
    console.log("Press Ctrl+C within 5 seconds to cancel...\n");
    await new Promise((resolve) => setTimeout(resolve, 5000));
  }

  console.log(`‚è∞ Started at: ${new Date().toLocaleString()}\n`);

  const result: SeedResult = {
    success: false,
    projectsDeleted: 0,
    projectsAdded: 0,
    errors: [],
    duration: 0,
  };

  try {
    // Step 1: Clear existing projects
    result.projectsDeleted = await clearProjects();

    // Step 2: Add seed projects
    const { successCount, errors } = await addSeedProjects();
    result.projectsAdded = successCount;
    result.errors = errors;

    // Determine overall success
    result.success = errors.length === 0;
    result.duration = Date.now() - startTime;

    // Print summary
    console.log("\n=====================================");
    console.log("üìä Seeding Summary");
    console.log("=====================================");
    console.log(`‚úÖ Projects deleted: ${result.projectsDeleted}`);
    console.log(`‚úÖ Projects added: ${result.projectsAdded}`);
    console.log(`‚ùå Errors: ${result.errors.length}`);
    console.log(`‚è±Ô∏è  Duration: ${result.duration}ms`);

    if (result.errors.length > 0) {
      console.log("\n‚ö†Ô∏è  Errors encountered:");
      result.errors.forEach((error, index) => {
        console.log(`   ${index + 1}. ${error}`);
      });
    }

    if (result.success) {
      console.log("\nüéâ Database seeding completed successfully!\n");
    } else {
      console.log(
        "\n‚ö†Ô∏è  Database seeding completed with errors. Check logs above.\n"
      );
    }

    return result;
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : "Unknown error";

    result.success = false;
    result.errors.push(errorMessage);
    result.duration = Date.now() - startTime;

    console.error("\n‚ùå Fatal error during seeding:");
    console.error(`   ${errorMessage}\n`);

    return result;
  }
}

// Execute the seeding script
main()
  .then((result) => {
    // Exit with appropriate code
    process.exit(result.success ? 0 : 1);
  })
  .catch((error) => {
    console.error("‚ùå Unhandled error:", error);
    process.exit(1);
  });
